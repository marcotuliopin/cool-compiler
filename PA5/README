
Write-up for PA5
----------------
**Marco Túlio de Pinho e Raul Araju**
--------------------------

## Tags

As classes básicas (Str, Int, Bool, IO e Object) receberam tags de 0 a 4. As novas classes receberam tags de 5 em diante de acordo com sua ordem na lista *classes*. Armazenamos as tags em um map, onde a chave é o nome da classe e o valor é a tag relacionada.

## Emitir: protótipos, nameTab e dispatch tables

Para esses papéis, criamos as funções *emit_nametab*, *emit_parenttab*, *emit_objtab*, *emit_dispatchtables* e *emit_prototypes*. Todas utilizam a busca em largura pela árvore de classes para realizar suas funções. Viu-se necessário acessar a árvore fora do escopo do objeto *CgenClassTable*, pois era preciso acessar as funções de uma classe por meio do seu nome. Para isso, criamos um gancho externo que permite acessar a raiz da árvore. Seguimos as especificações do Cool Runtime System na geração dos resultados das funções.

## Emitir: inicialização de objetos e métodos de classes

Para esses papéis, criamos as funções *emit_initializers* e *emit_methods*

## Métodos para produção de código para expressões

Reproduzimos as instruções em assembly que gerariam cada expressão por meio das funções *emit_** definidas no arquivo. Adicionamos a todos os métodos o parâmetro *Context &env*, necessário para se ter o escopo de execução de cada expressão.

## Ambiente de Execução (Context)

A classe `Context` guarda informações contextuais relacionadas ao processo de geração de código. Nesse sentido, ela mantém informações sobre o contexto atual durante a geração de código, incluindo a classe sendo processada, atributos da classe, argumentos do método e símbolos da pilha.

### Propósito:

1. **Informações da Classe:**
   - `Class_ cls`: Representa a classe atual sendo processada.

2. **Atributos da Classe:**
   - `std::vector<attr_class *> class_attrs`: Armazena atributos da classe para a classe atual.

3. **Argumentos do Método:**
   - `std::vector<Formal> mth_args`: Armazena argumentos do método para o método atual.

4. **Símbolos da Pilha:**
   - `std::vector<Symbol> stack_symbols`: Mantém uma pilha de símbolos para variáveis introduzidas no escopo atual.

### Acessadores e Modificadores:

   - `get_cls()`, `set_cls(Class_ cls)`: Obter e definir a classe atual.
   - `get_class_attrs_size()`: Obter o tamanho do vetor de atributos da classe.
   - `get_mth_args_size()`: Obter o tamanho do vetor de argumentos do método.
   - `add_cls_attr(attr_class *attr)`: Adicionar um atributo de classe ao vetor.
   - `add_mth_arg(Formal formal)`: Adicionar um argumento do método ao vetor.
   - `clear_mth_args()`: Limpar o vetor de argumentos do método.
   - `push_stack_symbol(Symbol name)`: Empurrar um símbolo para a pilha.
   - `pop_stack_symbol()`: Retirar um símbolo da pilha.

### Consultas Posicionais:

   - `get_let_var_pos_rev(Symbol name)`: Obter a posição (índice) de uma variável introduzida por `let` em ordem reversa na pilha.
   - `get_arg_pos(Symbol name)`: Obter a posição (índice) de um argumento do método.
   - `get_cls_attr_pos(Symbol name)`: Obter a posição (índice) de um atributo de classe.

A classe é projetada para gerenciar e consultar informações sobre o contexto atual, como hierarquia de classe, atributos, argumentos do método e variáveis locais. Essas informações são usadas durante a geração de código para rastrear vinculações de variáveis, resolver identificadores e gerar instruções apropriadas.